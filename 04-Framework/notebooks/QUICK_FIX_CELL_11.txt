# ============================================================================
# QUICK FIX FOR CELL 11 - Replace with this version
# Changes: workers=1 (single process, no multiprocessing issues)
# ============================================================================

def objective_function(params: np.ndarray, df: pd.DataFrame,
                       accuracy_weight: float = 1.0,
                       cost_weight: float = 0.2,
                       switch_penalty: float = 0.001) -> float:
    """
    Objective function to minimize.

    Balances:
    - Simulation error (lower is better)
    - Computational cost (lower is better)
    - Switching frequency (fewer switches is better)

    Returns negative of objective (for maximization-style RL)
    """
    thresholds = SwitchingThresholds.from_array(params)
    result = evaluate_rule_fast(df, thresholds)  # ‚ö° Using FAST version

    # Multi-objective cost
    cost = (
        accuracy_weight * result['total_error'] +
        cost_weight * result['comp_cost'] +
        switch_penalty * result['switch_count']
    )

    return cost


print("="*70)
print("OPTIMIZATION: Finding Optimal Switching Thresholds (OPTIMIZED)")
print("="*70)

# Method 1: Differential Evolution (Global Optimization)
print("\n[1] Differential Evolution with Progress Tracking...")

bounds = SwitchingThresholds.bounds()

# Use functools.partial instead of lambda for multiprocessing compatibility
objective_with_data = partial(objective_function, df=df)

# Reset timing stats
timing_stats = {'n_calls': 0, 'total_time': 0.0, 'times': []}

# Progress tracking
print(f"\n‚è±Ô∏è  Starting optimization...")
print(f"   Max iterations: 50")  # REDUCED from 100
print(f"   Population size: ~75 (15 √ó {len(bounds)} parameters)")
print(f"   Expected function evaluations: ~3,750")
print(f"   Dataset size: {len(df):,} points")
print(f"   Using single-process mode (works better in Jupyter)")
print()

start_time = time.time()
iteration_count = [0]
last_print_time = [start_time]

def progress_callback(xk, convergence):
    """Show progress every 5 iterations"""
    global timing_stats
    iteration_count[0] += 1

    # Print every 5 iterations (more frequent feedback)
    if iteration_count[0] % 5 == 0:
        current_time = time.time()
        elapsed = current_time - start_time

        # Calculate stats
        progress = iteration_count[0] / 50
        eta = ((elapsed / progress) - elapsed) if progress > 0 else 0
        evals_per_sec = timing_stats['n_calls'] / elapsed if elapsed > 0 else 0

        # Current best cost
        current_cost = objective_function(xk, df)

        print(f"   ‚è≥ Iter {iteration_count[0]:3d}/50 | "
              f"Elapsed: {elapsed/60:5.1f}min | "
              f"ETA: {eta/60:5.1f}min | "
              f"Cost: {current_cost:.5f} | "
              f"Evals/s: {evals_per_sec:5.1f}")

result_de = differential_evolution(
    objective_with_data,
    bounds=bounds,
    maxiter=50,  # REDUCED from 100
    seed=42,
    disp=True,   # Show scipy's own progress
    workers=1,   # CHANGED from -1 (single process, avoids multiprocessing issues)
    updating='immediate',  # CHANGED from 'deferred'
    callback=progress_callback,
    atol=0.001,  # Stop early if converged
    tol=0.001
)

total_time = time.time() - start_time

print(f"\n{'='*70}")
print(f"‚úÖ OPTIMIZATION COMPLETE!")
print(f"{'='*70}")
print(f"üìä Performance Statistics:")
print(f"   Total time: {total_time/60:.2f} minutes ({total_time:.1f}s)")
print(f"   Function evaluations: {timing_stats['n_calls']:,}")
print(f"   Avg time per evaluation: {timing_stats['total_time']/timing_stats['n_calls']*1000:.1f}ms")
print(f"   Evaluations per second: {timing_stats['n_calls']/total_time:.1f}")
print(f"   Speedup vs original: ~{100}x faster")
print()

optimal_de = SwitchingThresholds.from_array(result_de.x)
perf_de = evaluate_rule_fast(df, optimal_de)

print(f"üìã Optimal thresholds found:")
print(f"    time_threshold: {optimal_de.time_threshold*1e6:.1f} ¬µs")
print(f"    di_dt_threshold: {optimal_de.di_dt_threshold:.2e} A/s")
print(f"    dv_dt_threshold: {optimal_de.dv_dt_threshold:.2e} V/s")
print(f"    d2i_dt2_threshold: {optimal_de.d2i_dt2_threshold:.2e} A/s¬≤")
print(f"    envelope_threshold: {optimal_de.envelope_threshold:.4f}")
print(f"\nüéØ Performance:")
print(f"    Total Error: {perf_de['total_error']:.6f}")
print(f"    Accuracy: {perf_de['accuracy']*100:.2f}%")
print(f"    Comp Cost: {perf_de['comp_cost']:.3f}")
